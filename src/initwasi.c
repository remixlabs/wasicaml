#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <sys/stat.h>
#include <errno.h>

#include "wasicaml.h"

__attribute__((constructor))
static void init(void) {
    char *startdir = getenv("WASICAML_CWD");
    if (startdir != NULL) {
        if (chdir(startdir) == -1) {
            fprintf(stderr, "WASICAML: Cannot chdir to %s at startup.\n", startdir);
            _exit(2);
        }
    }
}

#ifdef HOST_EH
__attribute__((import_module("wasicaml")))
__attribute__((import_name("wasicaml_try")))
#endif
extern void * wasicaml_try(void *(*f)(void *), void *ctx);
// runs f(ctx) and catches any exceptions raised via wasicaml_throw.
// Returns NULL if such an exception was caught, and passes the return
// value of f back otherwise (which shouldn't be NULL).
// THIS CAN BE A HOST FUNCTION, AND IT DOESN'T NEED TO FIX UP
// THE SHADOW STACK POINTER AFTER CATCHING THE EXCEPTION.

#ifdef HOST_EH
__attribute__((import_module("wasicaml")))
__attribute__((import_name("wasicaml_try2")))
#endif
extern void * wasicaml_try2(void *(*f)(void *, void *),
                            void *ctx1, void *ctx2);
// Same but f is called with two context params:
// f(ctx1,ctx2)

#ifdef HOST_EH
__attribute__((import_module("wasicaml")))
__attribute__((import_name("wasicaml_try3")))
#endif
extern void * wasicaml_try3(void *(*f)(void *, void *, void *),
                            void *ctx1, void *ctx2, void *ctx3);
// Same but f is called with three context params:
// f(ctx1,ctx2,ctx3)

#ifdef HOST_EH
__attribute__((import_module("wasicaml")))
__attribute__((import_name("wasicaml_try4")))
#endif
extern void * wasicaml_try4(void * (*f)(void *, void *, void *, void *),
                            void *ctx1, void *ctx2, void *ctx3, void *ctx4);
// Same but f is called with four context params:
// f(ctx1,ctx2,ctx3,ctx4)

#ifdef HOST_EH
__attribute__((import_module("wasicaml")))
__attribute__((import_name("wasicaml_try5")))
#endif
extern void * wasicaml_try5(void * (*f)(void *, void *, void *, void *, void *),
                            void *ctx1, void *ctx2, void *ctx3, void *ctx4,
                            void *ctx5);
// Same but f is called with five context params:
// f(ctx1,ctx2,ctx3,ctx4,ctx5)

void * wasicaml_wraptry(void * (*f)(void *), void *ctx) {
    // The point of this wrapper is to save the stack pointer, and to
    // restore it on exit. The code for this is generated by the C compiler
    // when a local variable is present that cannot be optimized away.
    volatile int dummy = 0;
    return wasicaml_try(f, ctx);
}

void * wasicaml_wraptry2(void * (*f)(void *, void *),
                       void *ctx1, void *ctx2) {
    volatile int dummy = 0;
    return wasicaml_try2(f,ctx1,ctx2);
}

void * wasicaml_wraptry3(void * (*f)(void *, void *, void *),
                         void *ctx1, void *ctx2, void *ctx3) {
    volatile int dummy = 0;
    return wasicaml_try3(f,ctx1,ctx2,ctx3);
}

void * wasicaml_wraptry4(void * (*f)(void *, void *, void *, void *),
                         void *ctx1, void *ctx2, void *ctx3, void *ctx4) {
    volatile int dummy = 0;
    return wasicaml_try4(f,ctx1,ctx2,ctx3,ctx4);
}

void * wasicaml_wraptry5(void * (*f)(void *, void *, void *, void *, void*),
                         void *ctx1, void *ctx2, void *ctx3, void *ctx4,
                         void *ctx5) {
    volatile int dummy = 0;
    return wasicaml_try5(f,ctx1,ctx2,ctx3,ctx4,ctx5);
}

#ifdef HOST_EH
__attribute__((import_module("wasicaml")))
__attribute__((import_name("wasicaml_throw")))
__attribute__((noreturn))
extern void wasicaml_throw(void);
#endif

#ifdef WASM_EH
__attribute__((noreturn))
extern void wasicaml_throw(void);
#endif

void wasicaml_wrapthrow(void) {
    wasicaml_throw();
    abort();
}

#ifdef HOST_EH
__attribute__((export_name("wasicaml_call")))
void * wasicaml_call(void * (*f)(void *), void *ctx) {
    return f(ctx);
}

__attribute__((export_name("wasicaml_call2")))
void * wasicaml_call2(void * (*f)(void *, void *),
                      void *x1, void *x2) {
    return f(x1,x2);
}

__attribute__((export_name("wasicaml_call3")))
void * wasicaml_call3(void * (*f)(void *, void *, void *),
                      void *x1, void *x2, void *x3) {
    return f(x1,x2,x3);
}

__attribute__((export_name("wasicaml_call4")))
void * wasicaml_call4(void * (*f)(void *, void *, void *, void *),
                      void *x1, void *x2, void *x3, void *x4) {
    return f(x1,x2,x3,x4);
}

__attribute__((export_name("wasicaml_call5")))
void * wasicaml_call5(void * (*f)(void *, void *, void *, void *, void *),
                      void *x1, void *x2, void *x3, void *x4, void *x5) {
    return f(x1,x2,x3,x4,x5);
}
#endif

static char *__randname(char *template) {
    int i;
    struct timespec ts;
    unsigned long r;
    
    clock_gettime(CLOCK_REALTIME, &ts);
    r = ts.tv_nsec*65537 ^ (uintptr_t)&ts / 16 + (uintptr_t)template;
    for (i=0; i<6; i++, r>>=5)
        template[i] = 'A'+(r&15)+(r&16)*2;
    
    return template;
}

char *mktemp (char *template) {
    size_t l = strlen(template);
    int retries = 100;
    struct stat st;
    
    if (l < 6 || memcmp(template+l-6, "XXXXXX", 6)) {
        errno = EINVAL;
        *template = 0;
        return template;
    }
    
    do {
        __randname(template+l-6);
        if (stat(template, &st)) {
            if (errno != ENOENT) *template = 0;
            return template;
        }
    } while (--retries);
    
    *template = 0;
    errno = EEXIST;
    return template;
}
